#include <8051.h>

unsigned char time_count = 0;   // 設定 interrupt 數量，決定何時要 count ++

unsigned int sheet_loc = 0;    // 紀錄目前的拍子位置
const unsigned char sheet[361] = { // 樂譜
15,0,15,3,15,3,15,5,
15,6,15,5,15,6,15,8,15,7,15,6,5,  15,6,15,5,3,15,0,15,3,15,3,15,5,   15,6,15,5,15,6,15,8,15,7,15,6,15,6,15,3,  15,3,15,2,2,15,0,15,6,9,
6,9,15,0,15,6,15,9,15,6,   7,3,15,0,15,2,15,3,15,2,   5,15,0,15,2,15,5,15,6,15,7,15,8,   15,7,15,6,7,15,0,15,3,15,3,15,5,
15,6,15,5,15,6,15,8,15,7,15,6,15,5,15,6,    6,3,15,0,15,3,15,3,15,5,   15,6,15,5,15,6,15,8,15,7,15,6,15,6,15,5,    5,10,15,0,15,6,15,9,15,6,
17,9,15,0,15,10,15,7,15,6,   16,7,16,8,16,7,17,7,15,6,15,9,   15,7,15,3,15,6,15,9,15,7,15,3,15,6,15,5,    17,17,6,15,12,15,10,
9,15,0,15,9,15,9,15,10,15,8,15,9,    17,10,0,15,12,15,10,   9,15,0,15,9,15,9,15,5,15,10,15,11,   17,10,0,15,10,15,10,
14,15,10,15,9,9,15,8,15,7,    15,8,15,9,15,10,15,13,13,15,6,15,8,    15,10,15,9,15,6,15,8,7,5,    17,17,6,15,12,15,10,
9,15,0,15,9,15,9,15,10,15,8,15,9,    17,10,0,15,12,15,10,   9,15,0,15,9,15,9,15,5,15,10,15,11,   17,10,0,15,10,15,10,
14,15,10,15,9,9,15,8,15,7,    15,8,15,9,15,10,15,13,13,15,6,15,8,    15,10,15,9,15,6,15,8,7,5,    17,17,17,6,0
};

// 紀錄音符的頻率
unsigned short note[15] = {
    65536, 
    64580, 64686, 64778, 64820, 64899, 64968, 65030, 
    65058, 65110, 65157, 65178, 65217, 65252, 65283,
}; //中音Do, 中音Re, 中音Mi, 中音Fa, 中音So, 中音La, 中音Ti, 休止符隨便什麼音都可以

void setTimer(){
    /*
    * 設定 timer 0
    * 單位: 25000 微秒 = 0.025 s
    */

    // 設定 timer 0, timer 1
    TMOD = 0x11;    // 把 timer 0 & timer 1 的 mode 1 打開，並且使用 internal clock
                    // GATE=0, CT=0, (M1,M0)=01
                    // GATE=0, CT=0, (M1,M0)=01
                    // mode 1: 16bits(65535)

    TH0 = 0x9E;             //(65536-25000) / 256;
    TL0 = 0x58;             //(65536-25000) % 256;
    
    TR0 = 1;        // 啟動 timer 0
                    // 啟動條件: GATE=0 && TR0=1
    TR1 = 1;        // 啟動 timer 1
                    // 啟動條件: GATE=0 && TR1=1
}

void timer1_interrupt(void) __interrupt(3){
    /*
    * timer 0 跑到 65535，產生 interrupt (1)
    * 要計算已經跑完幾個 timer，10次(0.5秒)要 count += 1
    */
    TF1 = 0;                    // 把溢位 bits 關掉
    if(sheet[sheet_loc] == 0) {
        P3_4 = 0;
    }
    else {
        TH1 = note[sheet[sheet_loc]] / 256;
        TL1 = note[sheet[sheet_loc]] % 256;
        P3_4 = !P3_4;
    }
}

// unsigned char out = 0;
void timer0_interrupt(void) __interrupt (1){
    //一次 interrupt 代表 0.025s
    TF0 = 0;                    // 把溢位 bits 關掉
    if (sheet[sheet_loc] == 15) {
        sheet_loc = (sheet_loc + 1) % 361;
        time_count = 12; //25/2
    }
    else if (sheet[sheet_loc] == 16) {
        sheet_loc = (sheet_loc + 1) % 361;
        time_count = 18; //25*3/4
    }
    else if (sheet[sheet_loc] == 17) {
        sheet_loc = (sheet_loc + 1) % 361;
        time_count = -25; 
    }
    time_count += 1;
    if(time_count == 25){       // 25次(0.625秒)要 count += 1
        sheet_loc = (sheet_loc+1)%361;
        time_count = 0;
    }

    // 重新設定 timer 0
    TH0 = 0x9E;             //(65536-25000) / 256;
    TL0 = 0x58;             //(65536-25000) % 256;
    
}

void main(){

    IE = 0x8A;              // 1000 1010
                            // EA=1 (Enable Interrupts)
                            // ET1=1 (Enable timer 1 interrupt)
                            // ET0=1 (Enable timer 0 interrupt)
    // unsigned char out = 0;
    P3_4 = 1;
    
    TH0 = note[sheet_loc] / 256;
    TL0 = note[sheet_loc] % 256;

    setTimer();             // 開啟 timer 0, timer 1

    while(1){
    }
}



